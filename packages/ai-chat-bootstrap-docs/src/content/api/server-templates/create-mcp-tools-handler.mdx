---
title: createMcpToolsHandler
description: Minimal bridge endpoint used by the MCP client hooks to discover remote tool metadata.
---

# createMcpToolsHandler

`createMcpToolsHandler` ships a ready-made POST handler that proxies a single Model Context Protocol (MCP) server descriptor from the frontend to the AI SDK MCP client. It returns only the tool summaries that the UI needs to display available MCP capabilities.

> This handler is typically paired with the `useMCPServer` hook on the client and `createAIChatHandler` on the backend. The client controls which MCP servers are queried; the backend only needs an endpoint that accepts those descriptors.

## Import

```ts
import { createMcpToolsHandler } from "ai-chat-bootstrap/server";
```

## API Reference

```ts
interface CreateMcpToolsHandlerOptions {
  /**
   * Optional callback fired when the request body fails to parse
   * or the MCP client throws during tool discovery.
   */
  onError?: (error: unknown, ctx: { req: Request }) => void;
}

declare function createMcpToolsHandler(
  options?: CreateMcpToolsHandlerOptions
): (req: Request) => Promise<Response>;
```

### Request contract

The handler expects a JSON body shaped like:

```ts
interface MCPServerToolsRequest {
  server: SerializedMCPServer;
}

interface SerializedMCPServer {
  id: string;
  name?: string;
  transport: {
    type: "sse" | "streamable-http";
    url: string;
    headers?: Record<string, string>;
  };
}
```

This descriptor is generated on the client (`useMCPServer` or the MCP servers dialog) and includes everything the backend needs to open an MCP client connection.

### Response contract

On success the handler returns:

```ts
interface MCPServerToolsResponse {
  tools: Array<{ name: string; description?: string }>;
}
```

If the request is invalid or the MCP client fails, the response body is `{ error: string }` with status `400` or `500`.

## Example: Next.js App Router

```ts
// app/api/mcp/route.ts
import { createMcpToolsHandler } from "ai-chat-bootstrap/server";

const handler = createMcpToolsHandler({
  onError(error) {
    console.error("[mcp] failed to load tools", error);
  },
});

export { handler as POST };
```

The frontend should point `mcp.api` (or the `useMCPServer` hook) to `/api/mcp`.

## Example: Express

```ts
import express from "express";
import { createMcpToolsHandler } from "ai-chat-bootstrap/server";

const app = express();
const handleMcpTools = createMcpToolsHandler();

app.post("/api/mcp", express.json(), (req, res) => {
  handleMcpTools(
    new Request("http://localhost/api/mcp", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(req.body),
    })
  )
    .then(async (response) => {
      res.status(response.status);
      response.headers.forEach((value, key) => res.setHeader(key, value));
      res.send(await response.text());
    })
    .catch((error) => {
      console.error(error);
      res.status(500).json({ error: "Internal MCP bridge error" });
    });
});
```

## Frontend wiring

```tsx
import { ChatContainer, useMCPServer } from "ai-chat-bootstrap";

function DemoChat() {
  useMCPServer({
    id: "demo-mcp-server",
    name: "Demo MCP Toolkit",
    url: process.env.NEXT_PUBLIC_MCP_SERVER_URL ?? "http://127.0.0.1:3030/mcp",
    transportType: "streamable-http",
  });

  return (
    <ChatContainer
      transport={{ api: "/api/chat" }}
      mcp={{ enabled: true, api: "/api/mcp" }}
    />
  );
}
```

When a server is registered, the hook automatically POSTs the descriptor shown above to `/api/mcp`, stores the returned tool summaries, and exposes them to the chat UI. Those same summaries are merged into the enriched system prompt and forwarded to `createAIChatHandler`, which reconnects to the remote MCP servers during each chat request.
